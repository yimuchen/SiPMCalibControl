<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SiPM Calibration Control Program: Visual Class Reference</title>
<!-- Overriding the tabs css with our own -->
<!--link href="tabs.css" rel="stylesheet" type="text/css"/-->
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--Explicitly calling the including the stuff required for search-->
<!--<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
-->
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" />
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SiPM Calibration Control Program
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classVisual-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Visual Class Reference<div class="ingroups"><a class="el" href="group__hardware.html">Hardware Interface</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >As the visual process has a long startup time, a thread will be started whenever a visual system is declared, which will constantly flush the contents of the camera interface to a buffer, process the standardized image processing routine, and store the processed image and extracted variables, and repeat until some termination code is received. This looped thread will be briefly paused when the user request the image, to ensure the integrity of the transferred data. The core of the image processing functions is photodetector finding: finding the optimal "dark rectangle" within the image, and calculated in the center of this rectange in terms of pixel coordinates.</p>
<p >This will be the one interface functions that does not start use a singleton notation, as the system can potentially have more than 1 camera running similar algorithms.</p>
<h2><a class="el" href="classVisual.html" title="Visual system interface class.">Visual</a> processing thread management.</h2>
<p >There are 3 data members in the <a class="el" href="classVisual.html" title="Visual system interface class.">Visual</a> class used for managing the thread.</p><ul>
<li>std::thread loop_thead: the thread object for handling the loop function</li>
<li>std::atomic&lt;bool&gt; run_loop: the thread-safe flag variable to indicate whether the loop should continue.</li>
<li>std::mutex loop_mutex: Mutex lock required for data manipulation of the image containers.</li>
</ul>
<p >The main loop will basically loop over the following:</p><ul>
<li>Check if run_loop is true. Exit the loop if not.</li>
<li>Wait to lock the mutex.</li>
<li>Extract image and perform image processes</li>
<li>unlock the mutex.</li>
<li>Wait a fixed pause period.</li>
</ul>
<p >Under this model, the image extraction functions has windows in which it can choose to lock the mutex while it perform data extraction. The starting and stopping of the loop is also a simple check on the value of the <code>run_loop</code> variable.</p>
<h2><a class="el" href="classVisual.html" title="Visual system interface class.">Visual</a> processing algorithm for finding a photo detecting element</h2>
<p >The algorithm uses as much inbuilt OpenCV functions as possible to avoid being over taxing on the lowe power processing system the calibration stand is expected to run on. The algorithm is as follows:</p>
<ul>
<li>Convert the image into a binary image by some grayscale threshold value.</li>
<li>Use the binary image to generate a contours of the high-contrast features in the image.</li>
<li>For the found contours, the following filters is applied:<ul>
<li>The size (bounding box area), must be greater than some value (this removes noise speckles).</li>
<li>The ratio of the edges of the bounding box must be sufficiently similar (the photo detecting element is expected to be square.)</li>
<li>The internal area of the original image within the contour must be sufficiently dark (as photodetecting elements are expected to be gray)</li>
<li>The convex hull of the contour must be able to be approximated as a rectangle.</li>
</ul>
</li>
<li>The convex hull of the remaining contours will be used. The use of convex hulls is to eliminate reflection artifacts that might appear on the detector face.</li>
<li>The convex hull with the largest area will be assumed to be the detector element of interest, then the following parameters will be determined and stored in the VisualResults class:<ul>
<li>The average pixel position of the convex hull in (x,y)</li>
<li>The pixel position of the convex hull after polygon approximation</li>
<li>The sharpness measure of the surrounding image.</li>
</ul>
</li>
</ul>
<p >Functions should beable to receive a cv::Mat object as the input, to allow for arbitrary levels of debugging and feature demonstration. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVisual_1_1VisResult.html">VisResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1f77cfaf3109c695ae9c5a4ec3b6ef97"><td class="memItemLeft" align="right" valign="top"><a id="a1f77cfaf3109c695ae9c5a4ec3b6ef97" name="a1f77cfaf3109c695ae9c5a4ec3b6ef97"></a>
typedef std::vector&lt; cv::Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Contour_t</b></td></tr>
<tr class="separator:a1f77cfaf3109c695ae9c5a4ec3b6ef97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45942ac2f8e5c4733f51ceeecae34fd"><td class="memItemLeft" align="right" valign="top"><a id="aa45942ac2f8e5c4733f51ceeecae34fd" name="aa45942ac2f8e5c4733f51ceeecae34fd"></a>
typedef std::vector&lt; Contour_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ContourList</b></td></tr>
<tr class="separator:aa45942ac2f8e5c4733f51ceeecae34fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6e5995c1e85f6a27ddcc2c835f3f5ad9"><td class="memItemLeft" align="right" valign="top"><a id="a6e5995c1e85f6a27ddcc2c835f3f5ad9" name="a6e5995c1e85f6a27ddcc2c835f3f5ad9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Visual</b> (const std::string &amp;)</td></tr>
<tr class="separator:a6e5995c1e85f6a27ddcc2c835f3f5ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d0cd4b0247af22653e5e27183c7ca8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVisual.html#a78d0cd4b0247af22653e5e27183c7ca8">init_dev</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a78d0cd4b0247af22653e5e27183c7ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting the visual instance at the some device path.  <a href="classVisual.html#a78d0cd4b0247af22653e5e27183c7ca8">More...</a><br /></td></tr>
<tr class="separator:a78d0cd4b0247af22653e5e27183c7ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be7d23f0a59cbab89e367ddd118a5d2"><td class="memItemLeft" align="right" valign="top"><a id="a8be7d23f0a59cbab89e367ddd118a5d2" name="a8be7d23f0a59cbab89e367ddd118a5d2"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>FrameWidth</b> () const</td></tr>
<tr class="separator:a8be7d23f0a59cbab89e367ddd118a5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab330c57af5b37bf4926713f5f9a1bbe3"><td class="memItemLeft" align="right" valign="top"><a id="ab330c57af5b37bf4926713f5f9a1bbe3" name="ab330c57af5b37bf4926713f5f9a1bbe3"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>FrameHeight</b> () const</td></tr>
<tr class="separator:ab330c57af5b37bf4926713f5f9a1bbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a5d4b57d0adee00eba0a68a822386b"><td class="memItemLeft" align="right" valign="top"><a id="ab6a5d4b57d0adee00eba0a68a822386b" name="ab6a5d4b57d0adee00eba0a68a822386b"></a>
<a class="el" href="structVisual_1_1VisResult.html">VisResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetVisResult</b> ()</td></tr>
<tr class="memdesc:ab6a5d4b57d0adee00eba0a68a822386b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extraction of the visual processing results. <br /></td></tr>
<tr class="separator:ab6a5d4b57d0adee00eba0a68a822386b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7735b790d77eaf33bfe3dd49e84c167"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVisual.html#af7735b790d77eaf33bfe3dd49e84c167">GetImage</a> (const bool)</td></tr>
<tr class="memdesc:af7735b790d77eaf33bfe3dd49e84c167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extraction of the image, either the raw unprocessed image, or the descriptive image which includes the processed contours.  <a href="classVisual.html#af7735b790d77eaf33bfe3dd49e84c167">More...</a><br /></td></tr>
<tr class="separator:af7735b790d77eaf33bfe3dd49e84c167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eccc554e6ac1c6b82ba8abe9fed5909"><td class="memItemLeft" align="right" valign="top"><a id="a3eccc554e6ac1c6b82ba8abe9fed5909" name="a3eccc554e6ac1c6b82ba8abe9fed5909"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SaveImage</b> (const std::string &amp;, const bool raw)</td></tr>
<tr class="memdesc:a3eccc554e6ac1c6b82ba8abe9fed5909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving the image to some path. <br /></td></tr>
<tr class="separator:a3eccc554e6ac1c6b82ba8abe9fed5909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fa7214ef7b72a441af3274ffc07cc5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uchar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVisual.html#aa6fa7214ef7b72a441af3274ffc07cc5">GetImageBytes</a> ()</td></tr>
<tr class="memdesc:aa6fa7214ef7b72a441af3274ffc07cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returning the image as a JPEG encoded string.  <a href="classVisual.html#aa6fa7214ef7b72a441af3274ffc07cc5">More...</a><br /></td></tr>
<tr class="separator:aa6fa7214ef7b72a441af3274ffc07cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91676c34eb02387862935c452bcff0b0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; ContourList &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVisual.html#a91676c34eb02387862935c452bcff0b0">FindContours</a> (const cv::Mat &amp;) const</td></tr>
<tr class="memdesc:a91676c34eb02387862935c452bcff0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an base image, find the contours and group them according to the various selection criteria.  <a href="classVisual.html#a91676c34eb02387862935c452bcff0b0">More...</a><br /></td></tr>
<tr class="separator:a91676c34eb02387862935c452bcff0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067821b0c0b442f442757059365a74de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVisual_1_1VisResult.html">VisResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVisual.html#a067821b0c0b442f442757059365a74de">MakeResult</a> (const cv::Mat &amp;, const Contour_t &amp;) const</td></tr>
<tr class="memdesc:a067821b0c0b442f442757059365a74de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the original image in cv::Mat format, and the candidate convex contour, calculate the summary results.  <a href="classVisual.html#a067821b0c0b442f442757059365a74de">More...</a><br /></td></tr>
<tr class="separator:a067821b0c0b442f442757059365a74de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e93641ff63d0c20c124baf9019bf8d3"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVisual.html#a5e93641ff63d0c20c124baf9019bf8d3">MakeDisplay</a> (const cv::Mat &amp;, const std::vector&lt; ContourList &gt; &amp;) const</td></tr>
<tr class="memdesc:a5e93641ff63d0c20c124baf9019bf8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the original image in cv::Mat format, and the sorted list of countors found, generate a processed image with contours,.  <a href="classVisual.html#a5e93641ff63d0c20c124baf9019bf8d3">More...</a><br /></td></tr>
<tr class="separator:a5e93641ff63d0c20c124baf9019bf8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5f606904c07440f14dc25d93c986a6"><td class="memItemLeft" align="right" valign="top">ContourList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVisual.html#ade5f606904c07440f14dc25d93c986a6">GetRawContours</a> (const cv::Mat &amp;) const</td></tr>
<tr class="memdesc:ade5f606904c07440f14dc25d93c986a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thresholding and contouring algorithm.  <a href="classVisual.html#ade5f606904c07440f14dc25d93c986a6">More...</a><br /></td></tr>
<tr class="separator:ade5f606904c07440f14dc25d93c986a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b46c542684091db55c9889ce4dfdc1"><td class="memItemLeft" align="right" valign="top"><a id="a75b46c542684091db55c9889ce4dfdc1" name="a75b46c542684091db55c9889ce4dfdc1"></a>
Contour_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetConvexHull</b> (const Contour_t &amp;) const</td></tr>
<tr class="memdesc:a75b46c542684091db55c9889ce4dfdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstraction for computing the convex hull. <br /></td></tr>
<tr class="separator:a75b46c542684091db55c9889ce4dfdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29ab1579667f002294add26897acf01"><td class="memItemLeft" align="right" valign="top"><a id="ab29ab1579667f002294add26897acf01" name="ab29ab1579667f002294add26897acf01"></a>
Contour_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetPolyApprox</b> (const Contour_t &amp;) const</td></tr>
<tr class="memdesc:ab29ab1579667f002294add26897acf01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstraction for getting a polygon approximation. <br /></td></tr>
<tr class="separator:ab29ab1579667f002294add26897acf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceee7d9db78cceeccd7a4f5fe19b95b1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVisual.html#aceee7d9db78cceeccd7a4f5fe19b95b1">GetImageLumi</a> (const cv::Mat &amp;, const Contour_t &amp;) const</td></tr>
<tr class="memdesc:aceee7d9db78cceeccd7a4f5fe19b95b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the the original image and a contour of interest, computed the luminosity of the internal area.  <a href="classVisual.html#aceee7d9db78cceeccd7a4f5fe19b95b1">More...</a><br /></td></tr>
<tr class="separator:aceee7d9db78cceeccd7a4f5fe19b95b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e32aa20fc5c512d3fd820083e8df39"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVisual.html#a60e32aa20fc5c512d3fd820083e8df39">sharpness</a> (const cv::Mat &amp;, const cv::Rect &amp;) const</td></tr>
<tr class="memdesc:a60e32aa20fc5c512d3fd820083e8df39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the original image and a rectangular region of interest, compute the sharpness measure.  <a href="classVisual.html#a60e32aa20fc5c512d3fd820083e8df39">More...</a><br /></td></tr>
<tr class="separator:a60e32aa20fc5c512d3fd820083e8df39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a9253434e50f2f18fd89ddefad91bd"><td class="memItemLeft" align="right" valign="top"><a id="a47a9253434e50f2f18fd89ddefad91bd" name="a47a9253434e50f2f18fd89ddefad91bd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>GetContourSize</b> (const Contour_t &amp;) const</td></tr>
<tr class="memdesc:a47a9253434e50f2f18fd89ddefad91bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting the maximum measure of the contour (largest of the x/y measure) <br /></td></tr>
<tr class="separator:a47a9253434e50f2f18fd89ddefad91bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b621b6354183f884d307b8538826acf"><td class="memItemLeft" align="right" valign="top"><a id="a0b621b6354183f884d307b8538826acf" name="a0b621b6354183f884d307b8538826acf"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>GetContourMaxMeasure</b> (const Contour_t &amp;) const</td></tr>
<tr class="memdesc:a0b621b6354183f884d307b8538826acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting the maximum distance of two points within a contour. <br /></td></tr>
<tr class="separator:a0b621b6354183f884d307b8538826acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab67c02e3f71bb257f2ab84e35e19b476"><td class="memItemLeft" align="right" valign="top"><a id="ab67c02e3f71bb257f2ab84e35e19b476" name="ab67c02e3f71bb257f2ab84e35e19b476"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>CompareContourSize</b> (const Contour_t &amp;, const Contour_t &amp;)</td></tr>
<tr class="memdesc:ab67c02e3f71bb257f2ab84e35e19b476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison of contour size (bounding box area) <br /></td></tr>
<tr class="separator:ab67c02e3f71bb257f2ab84e35e19b476"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a8eae4a9d294fed8d9a3b0268e01152c6"><td class="memItemLeft" align="right" valign="top"><a id="a8eae4a9d294fed8d9a3b0268e01152c6" name="a8eae4a9d294fed8d9a3b0268e01152c6"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>dev_path</b></td></tr>
<tr class="separator:a8eae4a9d294fed8d9a3b0268e01152c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6f73ca3c88157f9ad7acea632da27e"><td class="memItemLeft" align="right" valign="top"><a id="a7a6f73ca3c88157f9ad7acea632da27e" name="a7a6f73ca3c88157f9ad7acea632da27e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>blur_range</b></td></tr>
<tr class="separator:a7a6f73ca3c88157f9ad7acea632da27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afced22fb33912afdc719417567062e8c"><td class="memItemLeft" align="right" valign="top"><a id="afced22fb33912afdc719417567062e8c" name="afced22fb33912afdc719417567062e8c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>lumi_cutoff</b></td></tr>
<tr class="separator:afced22fb33912afdc719417567062e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c2f3b116370202c6b2a59b4131b036"><td class="memItemLeft" align="right" valign="top"><a id="af4c2f3b116370202c6b2a59b4131b036" name="af4c2f3b116370202c6b2a59b4131b036"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>size_cutoff</b></td></tr>
<tr class="separator:af4c2f3b116370202c6b2a59b4131b036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e6649e82c71ef99ed7d3b89d11c7d7"><td class="memItemLeft" align="right" valign="top"><a id="a27e6649e82c71ef99ed7d3b89d11c7d7" name="a27e6649e82c71ef99ed7d3b89d11c7d7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>threshold</b></td></tr>
<tr class="separator:a27e6649e82c71ef99ed7d3b89d11c7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3661535903cf3c32801c66affb9253ac"><td class="memItemLeft" align="right" valign="top"><a id="a3661535903cf3c32801c66affb9253ac" name="a3661535903cf3c32801c66affb9253ac"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>ratio_cutoff</b></td></tr>
<tr class="separator:a3661535903cf3c32801c66affb9253ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da600cc147eb95128990e05a0dd8b5f"><td class="memItemLeft" align="right" valign="top"><a id="a0da600cc147eb95128990e05a0dd8b5f" name="a0da600cc147eb95128990e05a0dd8b5f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>poly_range</b></td></tr>
<tr class="separator:a0da600cc147eb95128990e05a0dd8b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:abbdb8a19042237f9218f0d7814aaaa71"><td class="memItemLeft" align="right" valign="top"><a id="abbdb8a19042237f9218f0d7814aaaa71" name="abbdb8a19042237f9218f0d7814aaaa71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>StartLoopThread</b> ()</td></tr>
<tr class="memdesc:abbdb8a19042237f9218f0d7814aaaa71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting the loop thread. <br /></td></tr>
<tr class="separator:abbdb8a19042237f9218f0d7814aaaa71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dbf5ab56b489a1cbf6ab95ce372453"><td class="memItemLeft" align="right" valign="top"><a id="a60dbf5ab56b489a1cbf6ab95ce372453" name="a60dbf5ab56b489a1cbf6ab95ce372453"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EndLoopThread</b> ()</td></tr>
<tr class="memdesc:a60dbf5ab56b489a1cbf6ab95ce372453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting the loop to stop and waiting for the thread to terminate. <br /></td></tr>
<tr class="separator:a60dbf5ab56b489a1cbf6ab95ce372453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7489217caf63d7afa323b7e051f935a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVisual.html#ad7489217caf63d7afa323b7e051f935a">RunMainLoop</a> (std::atomic&lt; bool &gt; &amp;)</td></tr>
<tr class="memdesc:ad7489217caf63d7afa323b7e051f935a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method used for running the loop.  <a href="classVisual.html#ad7489217caf63d7afa323b7e051f935a">More...</a><br /></td></tr>
<tr class="separator:ad7489217caf63d7afa323b7e051f935a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8277835225cbbf994bc502e5d5b127c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVisual.html#ac8277835225cbbf994bc502e5d5b127c">InitVarDefault</a> ()</td></tr>
<tr class="memdesc:ac8277835225cbbf994bc502e5d5b127c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default settings values of the algorithm.  <a href="classVisual.html#ac8277835225cbbf994bc502e5d5b127c">More...</a><br /></td></tr>
<tr class="separator:ac8277835225cbbf994bc502e5d5b127c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e3909e5a8c3e9c34e318b88ef79564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVisual_1_1VisResult.html">VisResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVisual.html#a26e3909e5a8c3e9c34e318b88ef79564">FindDetector</a> (const cv::Mat &amp;)</td></tr>
<tr class="memdesc:a26e3909e5a8c3e9c34e318b88ef79564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given image in cv::Mat format. Compute the visual algorithm results and stored in a processed version of the image in the internal buffer.  <a href="classVisual.html#a26e3909e5a8c3e9c34e318b88ef79564">More...</a><br /></td></tr>
<tr class="separator:a26e3909e5a8c3e9c34e318b88ef79564"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a57b2325c646f71c5d56513f61b2b180b"><td class="memItemLeft" align="right" valign="top"><a id="a57b2325c646f71c5d56513f61b2b180b" name="a57b2325c646f71c5d56513f61b2b180b"></a>
cv::VideoCapture&#160;</td><td class="memItemRight" valign="bottom"><b>cam</b></td></tr>
<tr class="separator:a57b2325c646f71c5d56513f61b2b180b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afd06f800bf7e0c243c507b801185a7"><td class="memItemLeft" align="right" valign="top"><a id="a3afd06f800bf7e0c243c507b801185a7" name="a3afd06f800bf7e0c243c507b801185a7"></a>
cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><b>image</b></td></tr>
<tr class="separator:a3afd06f800bf7e0c243c507b801185a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcfa0af920504994adda131d52cc97b"><td class="memItemLeft" align="right" valign="top"><a id="a3bcfa0af920504994adda131d52cc97b" name="a3bcfa0af920504994adda131d52cc97b"></a>
cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><b>display</b></td></tr>
<tr class="separator:a3bcfa0af920504994adda131d52cc97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8dd2b154c296a9bc9bfe318b82f018"><td class="memItemLeft" align="right" valign="top"><a id="abb8dd2b154c296a9bc9bfe318b82f018" name="abb8dd2b154c296a9bc9bfe318b82f018"></a>
<a class="el" href="structVisual_1_1VisResult.html">VisResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>latest</b></td></tr>
<tr class="separator:abb8dd2b154c296a9bc9bfe318b82f018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e89ef6618fd7af728710709a083f9a9"><td class="memItemLeft" align="right" valign="top"><a id="a4e89ef6618fd7af728710709a083f9a9" name="a4e89ef6618fd7af728710709a083f9a9"></a>
std::thread&#160;</td><td class="memItemRight" valign="bottom"><b>loop_thread</b></td></tr>
<tr class="separator:a4e89ef6618fd7af728710709a083f9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae176b58a597d086b90b8ae7b5e4ffa57"><td class="memItemLeft" align="right" valign="top"><a id="ae176b58a597d086b90b8ae7b5e4ffa57" name="ae176b58a597d086b90b8ae7b5e4ffa57"></a>
std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>run_loop</b></td></tr>
<tr class="separator:ae176b58a597d086b90b8ae7b5e4ffa57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f1b08986621bcc51985e679bbbc548"><td class="memItemLeft" align="right" valign="top"><a id="ab0f1b08986621bcc51985e679bbbc548" name="ab0f1b08986621bcc51985e679bbbc548"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>loop_mutex</b></td></tr>
<tr class="separator:ab0f1b08986621bcc51985e679bbbc548"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a91676c34eb02387862935c452bcff0b0" name="a91676c34eb02387862935c452bcff0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91676c34eb02387862935c452bcff0b0">&#9670;&nbsp;</a></span>FindContours()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Visual::ContourList &gt; Visual::FindContours </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Storing outputs of the opencv contouring algorithm according to where they pass the selection:</p><ul>
<li>If they fail the minimal size requirements, these contours are discarded as these are typically imaging "speckles" that comes from image sensor noise.</li>
<li>All other selection criteria (rectangular approximation, luminosity requirements, size requirements... etc) should always be store, as failed contours is a good indication for which parameters need to be tuned for when the algorithm apparently fails. </li>
</ul>

</div>
</div>
<a id="a26e3909e5a8c3e9c34e318b88ef79564" name="a26e3909e5a8c3e9c34e318b88ef79564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e3909e5a8c3e9c34e318b88ef79564">&#9670;&nbsp;</a></span>FindDetector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVisual_1_1VisResult.html">Visual::VisResult</a> Visual::FindDetector </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This handles the main control flow of:</p><ul>
<li>Extracting the image.</li>
<li>Running the contouring algorithm</li>
<li>Morphing the results into the standard <a class="el" href="structVisual_1_1VisResult.html">VisResult</a> format. </li>
</ul>

</div>
</div>
<a id="af7735b790d77eaf33bfe3dd49e84c167" name="af7735b790d77eaf33bfe3dd49e84c167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7735b790d77eaf33bfe3dd49e84c167">&#9670;&nbsp;</a></span>GetImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat Visual::GetImage </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >In the rare event that the frame is empty (either because the camera was never properly initialized, or that there was an issue with the image transfer process), a blank (all 0 value image) with the correct dimensions will be returned to ensure that all subsequent functions will function nominally. </p>

</div>
</div>
<a id="aa6fa7214ef7b72a441af3274ffc07cc5" name="aa6fa7214ef7b72a441af3274ffc07cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6fa7214ef7b72a441af3274ffc07cc5">&#9670;&nbsp;</a></span>GetImageBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uchar &gt; Visual::GetImageBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This method is required by the GUI interface to allow for streaming of data via HTTP image requests. </p>

</div>
</div>
<a id="aceee7d9db78cceeccd7a4f5fe19b95b1" name="aceee7d9db78cceeccd7a4f5fe19b95b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceee7d9db78cceeccd7a4f5fe19b95b1">&#9670;&nbsp;</a></span>GetImageLumi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Visual::GetImageLumi </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Contour_t &amp;&#160;</td>
          <td class="paramname"><em>cont</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Here we use the conversion to luminosity using the formula found here: <a href="https://en.wikipedia.org/wiki/Relative_luminance">https://en.wikipedia.org/wiki/Relative_luminance</a> </p>

</div>
</div>
<a id="ade5f606904c07440f14dc25d93c986a6" name="ade5f606904c07440f14dc25d93c986a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5f606904c07440f14dc25d93c986a6">&#9670;&nbsp;</a></span>GetRawContours()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Visual::Contour_t &gt; Visual::GetRawContours </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >An extra blur is applied to the gray-scaled image to avoid noise speckles from affecting the sharpness measure. </p>

</div>
</div>
<a id="a78d0cd4b0247af22653e5e27183c7ca8" name="a78d0cd4b0247af22653e5e27183c7ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d0cd4b0247af22653e5e27183c7ca8">&#9670;&nbsp;</a></span>init_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Visual::init_dev </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The device path on a unix machine will typically be something like: <code>/dev/video0</code>, input whatever camera device is used for the system. Notice that the camera device would need to be covered by the v462 Linux video device drivers to function properly on the real system.</p>
<p >In addition: we will ensure the following settings on the camera device:</p><ul>
<li>Fix the resolution as 1280x1024. This ensures that the visual processing algorithm will perform in realtime</li>
<li>Reduce the buffer to 0. This ensures that the image received from the camera will be as close to real time as possible.</li>
<li>Switch <b>off</b> any known image processing. This is so that image processing artifacts does not skew the image processing algorithms we use.</li>
</ul>
<p >A thread will be started as soon as the devices is known to be availabe. </p>

</div>
</div>
<a id="ac8277835225cbbf994bc502e5d5b127c" name="ac8277835225cbbf994bc502e5d5b127c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8277835225cbbf994bc502e5d5b127c">&#9670;&nbsp;</a></span>InitVarDefault()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Visual::InitVarDefault </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Last determined 2021.05.31. </p>

</div>
</div>
<a id="a5e93641ff63d0c20c124baf9019bf8d3" name="a5e93641ff63d0c20c124baf9019bf8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e93641ff63d0c20c124baf9019bf8d3">&#9670;&nbsp;</a></span>MakeDisplay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat Visual::MakeDisplay </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ContourList &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Each different fail mode displayed in a different color for debugging simple debugging. The return is the processed image in a standard opencv::Mat data format. </p>

</div>
</div>
<a id="a067821b0c0b442f442757059365a74de" name="a067821b0c0b442f442757059365a74de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067821b0c0b442f442757059365a74de">&#9670;&nbsp;</a></span>MakeResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVisual_1_1VisResult.html">Visual::VisResult</a> Visual::MakeResult </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Contour_t &amp;&#160;</td>
          <td class="paramname"><em>hull</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The summary results include:</p><ul>
<li>The average position in pixels in the area covered by the contour.</li>
<li>The sharpness measure (2nd and 4th order), calculated in a bounding rectangle twice the size of the original bounding rectangle.</li>
<li>The area (in pixels) of the convex hull</li>
<li>The maximum distance fo two points in the contour</li>
<li>The 8 coordinates of the corners after polygon approximation. </li>
</ul>

</div>
</div>
<a id="ad7489217caf63d7afa323b7e051f935a" name="ad7489217caf63d7afa323b7e051f935a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7489217caf63d7afa323b7e051f935a">&#9670;&nbsp;</a></span>RunMainLoop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Visual::RunMainLoop </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>run_loop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The atomic object needs to be passed in as a argument to function properly. In between loop iterations, a fixed 5 millisecond paused is used to ensure that other processes has a chance to extract image and processing results when requested. This pause must be faster than the camera refresh rate to have a real-time like iamge presentation in the GUI program. </p>

</div>
</div>
<a id="a60e32aa20fc5c512d3fd820083e8df39" name="a60e32aa20fc5c512d3fd820083e8df39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e32aa20fc5c512d3fd820083e8df39">&#9670;&nbsp;</a></span>sharpness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; Visual::sharpness </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Rect &amp;&#160;</td>
          <td class="paramname"><em>crop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The sharpness measure is defined by taking the gray-scaled image apply a small blur, then compute the laplace transfromed image. Then taking the standard deviation (2nd order variance) and Kurtosis measure (4th order variance) of the transformed image. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/github/workspace/src/<a class="el" href="visual_8hpp_source.html">visual.hpp</a></li>
<li>/github/workspace/src/<a class="el" href="visual_8cc.html">visual.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/>
  <address class="footer">
    <small>
    Generated by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.9.2
    </small>
  </address>
  <address class="footer">
    <small>
    Source code hosted on<a href="http://github.com">GitHub</a>
    </small>
  </address>
  <address class="footer">
    <small id="debugger">
    Debug:
    </small>
  </address>
<!-- custom Javascript stuff -->
  <script type="text/javascript" src="customjs/summary.js"></script>
</body>
</html>
